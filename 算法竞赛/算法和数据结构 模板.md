# 并查集
```
const int N = 2e5 + 5;
int a[N];
int fa[N];
int find(int x)
{
    if (fa[x] != x)
        fa[x] = find(fa[x]);
    return fa[x];
}
bool isSame(int x, int y)
{
    return find(x) == find(y);
}
void Union(int x, int y)
{
    fa[find(x)] = find(y);
}
```

# 最小生成树 Kruskal算法
```
const int MX = 2e5 + 5;
struct Edg
{
    int l, x, y;
};
Edg edg[MX];
int fa[5005];
int find(int x)
{
    if (fa[x] != x)
    {
        fa[x] = find(fa[x]);
    }
    return fa[x];
}
bool unite(int x, int y)
{
    int fx = find(x);
    int fy = find(y);
    if (fx == fy)
        return false;
    fa[fx] = fy;
    return true;
}

void solve()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        fa[i] = i;
    }
    int cnt = 0;
    ll ans = 0;
    for (int i = 1; i <= m; i++)
        cin >> edg[i].x >> edg[i].y >> edg[i].l;
        
    sort(edg + 1, edg + 1 + m, [](const Edg &a, const Edg &b) {
        return a.l < b.l;
    });
    
    for (int i = 1; i <= m; i++)
    {
        if (unite(edg[i].x, edg[i].y))
        {
            ans += edg[i].l;
            cnt++;
        }
    }
    
    if (cnt == n - 1)
        cout << ans << "\n";
    else
        cout << "orz\n";
}
```

# 线段树
```
#define int long long

const int N = 1e5 + 5;

int a[N];

int sum[N * 4];

int add[N * 4];

void up(int i)

{

    sum[i] = sum[i * 2] + sum[i * 2 + 1];

}

void lazy(int i, int v, int n)

{

    sum[i] += v * n;

  

    add[i] += v;

}

void down(int i, int ln, int rn)

{

    if (add[i])

    {

        lazy(i * 2, add[i], ln);

        lazy(i * 2 + 1, add[i], rn);

        add[i] = 0;

    }

}

void build(int l, int r, int i)

{

    if (l == r)

        sum[i] = a[l];

    else

    {

        int mid = (l + r) / 2;

        build(l, mid, i * 2);

        build(mid + 1, r, i * 2 + 1);

        up(i);

    }

    add[i] = 0;

}

void mfy(int jobl, int jobr, int jobv, int l, int r, int i)

{

    if (jobl <= l && r <= jobr)

    {

        lazy(i, jobv, r - l + 1);

    }

  

    else

    {

        int mid = (l + r) >> 1;

        down(i, mid - l + 1, r - mid);

        if (jobl <= mid)

        {

            mfy(jobl, jobr, jobv, l, mid, i * 2);

        }

        if (jobr > mid)

        {

            mfy(jobl, jobr, jobv, mid + 1, r, i * 2 + 1);

        }

        up(i);

    }

}

int que(int jobl, int jobr, int l, int r, int i)

{

    if (jobl <= l && r <= jobr)

    {

        return sum[i];

    }

    int mid = (l + r) / 2;

    down(i, mid - l + 1, r - mid);

    int ans = 0;

    if (jobl <= mid)

    {

        ans += que(jobl, jobr, l, mid, i * 2);

    }

    if (jobr > mid)

    {

        ans += que(jobl, jobr, mid + 1, r, i * 2 + 1);

    }

    return ans;

}
```

# 权值线段树
```
const int N = 4e5 + 5;

int a[N];

int val[N];

int k;

map<int, int> cnt;

int sum[N * 4];

int tcnt[N * 4];

  

struct Op

{

    int typ;

    ll p, l, r;

} ops[200005];

  

void up(int i)

{

    tcnt[i] = tcnt[i * 2] + tcnt[i * 2 + 1];

    sum[i] = sum[i * 2] + sum[i * 2 + 1];

}

  

void build(int l, int r, int i)

{

    if (l == r)

    {

        tcnt[i] = cnt[val[l]];

        sum[i] = tcnt[i] * val[l];

        return;

    }

    int mid = (l + r) / 2;

    build(l, mid, 2 * i);

    build(mid + 1, r, 2 * i + 1);

    up(i);

}

  

void mfy(int l, int r, int i, int pos, int v)

{

    if (l == r)

    {

        tcnt[i] += v;

        sum[i] += v * val[l];

        return;

    }

    int mid = (l + r) / 2;

    if (pos <= mid)

        mfy(l, mid, i * 2, pos, v);

    else

        mfy(mid + 1, r, i * 2 + 1, pos, v);

    up(i);

}

  

int que(int jobl, int jobr, int l, int r, int i)

{

    if (jobl > jobr)

        return 0;

    if (jobl <= l && r <= jobr)

    {

        return sum[i];

    }

    int mid = (l + r) / 2;

    int ans = 0;

    if (jobl <= mid)

    {

        ans += que(jobl, jobr, l, mid, i * 2);

    }

    if (jobr >= mid + 1)

    {

        ans += que(jobl, jobr, mid + 1, r, i * 2 + 1);

    }

    return ans;

}

  

void solve()

{

    int n;

    cin >> n;

    int j = 1;

    for (int i = 1; i <= n; i++)

    {

        cin >> a[j];

        cnt[a[j]]++;

        j++;

    }

    int q;

    cin >> q;

    for (int i = 1; i <= q; i++)

    {

        cin >> ops[i].typ;

        if (ops[i].typ == 1 || ops[i].typ == 2)

        {

            cin >> ops[i].p;

            a[j++] = ops[i].p;

        }

        else

        {

            cin >> ops[i].l >> ops[i].r;

        }

    }

  

    sort(a + 1, a + j);

    k = 0;

    for (int i = 1; i < j; i++)

    {

        if (i == 1 || a[i] != a[i - 1])

        {

            val[++k] = a[i];

        }

    }

  

    build(1, k, 1);

  

    for (int i = 1; i <= q; i++)

    {

        if (ops[i].typ == 1)

        {

            int pt = lower_bound(val + 1, val + k + 1, ops[i].p) - val;

            mfy(1, k, 1, pt, 1);

        }

        else if (ops[i].typ == 2)

        {

            int pt = lower_bound(val + 1, val + k + 1, ops[i].p) - val;

            mfy(1, k, 1, pt, -1);

        }

        else if (ops[i].typ == 3)

        {

            int jl = lower_bound(val + 1, val + k + 1, ops[i].l) - val;

            int jr = upper_bound(val + 1, val + k + 1, ops[i].r) - val - 1;

            cout << que(jl, jr, 1, k, 1) << "\n";

        }

    }

}
```

# 对拍

```
#include <bits/stdc++.h>

int main()

{

    srand(time(0));

    freopen("in.in", "w", stdout);

    int a = rand(), b = rand();

    std::ios::sync_with_stdio(false);

    std::cin.tie(nullptr);

    std::cout << a << ' ' << b << '\n';

}
```

```
#include <bits/stdc++.h>

int main()

{

    freopen("in.in", "r", stdin);      

    freopen("baoli.txt", "w", stdout);

    int a, b, ans = 0;

    std::ios::sync_with_stdio(false);

    std::cin.tie(nullptr);

  

    std::cin >> a >> b;

    for (int i = 1; i <= a; ++i)

        ans++;

    for (int i = 1; i <= b; ++i)

        ans++;

    std::cout << ans << '\n';

}
```

```
#include <bits/stdc++.h>

int main()

{

    freopen("in.in", "r", stdin);

    freopen("true.txt", "w", stdout);

    int a,b;

    std::ios::sync_with_stdio(false);

    std::cin.tie(nullptr);

  

    std::cin >> a >> b;

    std::cout << (a + b) << '\n';

}
```

```
#include<bits/stdc++.h>

using namespace std;

int main()

{

    while (1)

    {

        system("data.exe");

        system("baoli.exe");

        system("true.exe");

        if (system("fc true.txt baoli.txt"))

            break;

    }

    return 0;

}
```
