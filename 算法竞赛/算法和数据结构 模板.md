# 并查集DSU
```
const int N = 2e5 + 5;
int a[N];
int fa[N];
int find(int x)
{
    if (fa[x] != x)
        fa[x] = find(fa[x]);
    return fa[x];
}
bool isSame(int x, int y)
{
    return find(x) == find(y);
}
void Union(int x, int y)
{
    fa[find(x)] = find(y);
}
```

# 最小生成树MST Kruskal算法
```
const int MX = 2e5 + 5;
struct Edg
{
    int l, x, y;
};
Edg edg[MX];
int fa[5005];
int find(int x)
{
    if (fa[x] != x)
    {
        fa[x] = find(fa[x]);
    }
    return fa[x];
}
bool unite(int x, int y)
{
    int fx = find(x);
    int fy = find(y);
    if (fx == fy)
        return false;
    fa[fx] = fy;
    return true;
}

void solve()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        fa[i] = i;
    }
    int cnt = 0;
    ll ans = 0;
    for (int i = 1; i <= m; i++)
        cin >> edg[i].x >> edg[i].y >> edg[i].l;
        
    sort(edg + 1, edg + 1 + m, [](const Edg &a, const Edg &b) {
        return a.l < b.l;
    });
    
    for (int i = 1; i <= m; i++)
    {
        if (unite(edg[i].x, edg[i].y))
        {
            ans += edg[i].l;
            cnt++;
        }
    }
    
    if (cnt == n - 1)
        cout << ans << "\n";
    else
        cout << "orz\n";
}
```

# 单调栈 
```
	
```
