比赛题目：
1.  [校赛线上赛](https://oj.redrock.team/contest/16)
2. [校赛线下赛](https://oj.redrock.team/contest/17)

# A题
汉诺塔问题有一些结论可以在做题时用到。下面所讨论的都是最优的情况。
## 1. 递归规模特性
就盘子数 **n** 而言，通过递归可以得到，从 **A** 柱移动到 **C** 柱所需的总次数 **f(n)** 遵循以下关系：
**f(n) = 2 * f(n-1) + 1**
## 2. 二进制表示与状态映射
对于移动次数，可以利用其二进制特征进行分析：
- 将其二进制表示，**最低一个等于 1 的位**是所需要移动的盘子编号。
- 从最高位前缀和到这一位是已经移动过的次数。    
- 注意前缀和时每一位的贡献是乘以权重的，权重是二进制下的位数。
## 3. 移动顺序与奇偶性规律
圆盘的移动路径受到总盘数与盘子编号奇偶性的约束：
- 若盘子数和所移动的盘子奇偶性一致，移动顺序依次是 **A -> C -> B**。
- 否则，移动顺序是 A -> B -> C。
根据性质解题即可。

---

# C题
## 1. 核心思路
- **求中位数**，可以 **对顶堆模板** 解决。
- **l** 是较小的前一半数 **大根堆**（升序排列），**r** **小根堆**（降序排列）。
## 2. 取值规则
- **偶数时**：**l**、**r** 个数相等，取靠左的即 **l** 中的最大值。
- **奇数时**：设置成 **l** 可以比 **r** 元素个数多 **1**，从而奇数时可以取到。
- **结论**：无论奇偶都取 **l.top()** 保证一致性。
## 3. 注意事项
**添加数到 l 的条件**：需满足 **l.empty()** 或 **x <= l.top()**。
- **原因**：这样保证不会是大数进来占据 **top** 位置。    
- **后果**：否则导致本该在后半部分的数到前一半，未经排序导致失效。

---

# D题
尝试过贪心后发现错误，尝试使用DP求解。
实际上是一道**区间DP**模板题，两重循环遍历长度len和起点i可以求出当前的日期y与终点j。
用 $dp[i][j]$ 表示 $[i, j]$ 这一段区间最大收益。只能由左右两边转移而来。
找到状态转移方程解决问题。
```
            dp[i][j]=max(dp[i+1][j]+y*a[i],dp[i][j-1]+y*a[j]);
```
另外注意开longlong，以及dp数组至少要开n+2大小，因为$dp[i+1][j]$中i是可以取n的，base1所以至少开n+2。

---

# E题
看到数据范围和时间限制宽松，发现n方可以通过。只需两重循环分别作为起点终点来遍历区间，满足完美序列定义即可更新当前区间答案大小。由定义分析出两条性质 1.区间最大值等于长度；2.没有重复出现的数字。分别用max和set进行维护。
题解给出了另外一种思路。异或运算满足交换率和结合率，以及它的自反性可以满足排列的性质。前缀异或不用考虑排列的顺序，只用考虑是否出现过。利用哈希将数组元素映射为较大数字，避免异或和冲突。前缀异或和预处理数组，预处理完美排列，同样n方遍历。不用分析性质，而是比较值是否相等，相等更新最大值。

---

# G题
首先特判AB在x轴两侧的情况、A或B在x轴上的情况、xb<xa情况、dy>dx情况、dx-dy是奇数情况，答案为0。
对于一般情况，可以使用间接法解决，用全部的数量减去穿过x轴的数量。
yb-ya == n上-n下，xb-xa== n上＋n下，解方程组后用组合数计算。注意到组合数取模，要使用快速幂。
穿过x轴的路径数量，可以看作A关于关于x轴对称的点到B的路径数量，解决办法相同。

---

# I题
题目难点在于建图。如果正常建图，直接建图复杂度是ai×bi的级别。可以使用虚点将复杂度优化到ai＋bi。注意建图时设置集合A内点到pi权值为1，po到A内点权值0；pi到B内点权值0，B内点到po权值1。可以直接dij找最短路，也可以使用deque进行01bfs求解。bfs的时间复杂度比dij少一个log，因为优先队列底层堆实现，找最小值复杂度是log级别。

---

# J题
是一道线段树＋扫描线的题目。先利用前缀后缀数组预处理，可以直接O(1)访问得到第三段的值。第三段可以直接访问得到，我们只需要维护前两段的和最大，使用线段树进行维护。将第二个截断作为线i进行扫描。将第一段值作为线段树叶子节点值，非叶子节点是它的两个儿子的最大值，递归建树，up更新。扫描线向右扫到一个值，自这个值上一次出现以后的位置pos往左截断，都会使得维护的和加一。如果范围被覆盖直接全部加，否则子节点使用懒标记延迟更新，向下递归一层并up。询问时递归，找到1到i-1之间截断使得前两段和最大。

---

# 线下C题
二维偏序但是由于has大于等于零，所以可以贪心求解。对一维使用优先队列或者set排序，所有小于x0的放入另一个优先队列或set，再对另一维同样操作，修改答案。

---

# 线下K题
双向搜索，记忆化用map存每个位置当前值出现的次数。两边都搜索，到对角线结束。